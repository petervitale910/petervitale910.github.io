[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "All my favorite resources",
    "section": "",
    "text": "this is an h1 element\n\n\nthis is an h1 element with the title class\n\n\nthis paragraph is butterscotch\n\n\nthis paragraph is centered\n\n\nthis paragraph is centered and butterscotch\n\n\nHere’s where I’m describing something fun that I enjoy doing\n\nThis\nis\nall\nbutterscotch\n\n\nThis\nis\nall\ncentered"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am currently a student who works"
  },
  {
    "objectID": "about.html#what-i-do-for-work",
    "href": "about.html#what-i-do-for-work",
    "title": "About",
    "section": "",
    "text": "I am currently a student who works"
  },
  {
    "objectID": "about.html#what-i-do-for-fun",
    "href": "about.html#what-i-do-for-fun",
    "title": "About",
    "section": "What I do for fun",
    "text": "What I do for fun\nLeague of Legends; give the ppl what they want."
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html",
    "href": "posts/aquaculture_and_eezs/index.html",
    "title": "Aquaculture and EEZ’s",
    "section": "",
    "text": "DESCRIPTION OF EEZ”S AND WHY I LIKE THIS\nCode\npacman::p_load('tidyverse', \n               'sf', \n               'here',\n               'tmap', \n               'kableExtra',\n               'patchwork',\n               'stars',\n               'terra')"
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html#data-import",
    "href": "posts/aquaculture_and_eezs/index.html#data-import",
    "title": "Aquaculture and EEZ’s",
    "section": "Data import",
    "text": "Data import\n\nSurface temperature from: [@noaa_crw_sst31]\n\n\nCode\nsst_2008 &lt;- rast(here('posts', 'aquaculture_and_eezs','data',\n                      'average_annual_sst_2008.tif')) \n\nsst_2009 &lt;- rast(here('posts', 'aquaculture_and_eezs','data',\n                      'average_annual_sst_2009.tif'))\nsst_2010 &lt;- rast(here('posts', 'aquaculture_and_eezs', 'data',\n                      'average_annual_sst_2010.tif'))\nsst_2011 &lt;- rast(here('posts', 'aquaculture_and_eezs','data',\n                      'average_annual_sst_2011.tif'))\nsst_2012 &lt;- rast(here('posts', 'aquaculture_and_eezs', 'data',\n                      'average_annual_sst_2012.tif'))\n\n\n\n\nBathymetry\nFrom: [@gebcobathymetriccompilationgroup20252025]\n\n\nCode\nbathy &lt;- rast(here('posts', 'aquaculture_and_eezs', 'data','depth.tif')) %&gt;% \n  project(\"EPSG:4326\") # Coerce into correct crs \n\n\n\n\nExclusive Economic Zones\nFrom: [@marine_regions_eez_v12]\n\n\nCode\neez &lt;- st_read(here('posts', 'aquaculture_and_eezs','data',\n                    'wc_regions_clean.shp'), quiet = TRUE) %&gt;% \n  st_transform(\"EPSG:4326\") # STARS OBJECT"
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html#surface-temperature-mean",
    "href": "posts/aquaculture_and_eezs/index.html#surface-temperature-mean",
    "title": "Aquaculture and EEZ’s",
    "section": "Surface temperature mean",
    "text": "Surface temperature mean\n\n\nCode\n# Stacked raster\nstacked_sst &lt;- c(sst_2008, sst_2009, sst_2010, sst_2011, sst_2012) %&gt;% # Here we stack our temperatures and then transform crs\n  project(\"EPSG:4326\") \n\n# Take mean of stacked raster and transform from Kelvin to Celsius\nmean_sst &lt;- mean(stacked_sst) - 273.15"
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html#bathymetry-1",
    "href": "posts/aquaculture_and_eezs/index.html#bathymetry-1",
    "title": "Aquaculture and EEZ’s",
    "section": "Bathymetry",
    "text": "Bathymetry\n\n\nCode\n# First we need to assure this data is in the same crs as sst\ndepth_projected &lt;- project(bathy, mean_sst) # Project the crs of mean sst on depth \n\ncrs(depth_projected) == crs(mean_sst)\n\n\n[1] TRUE\n\n\nCode\n# We are going to crop the depth raster to the eez\ndepth_cropped &lt;- crop(depth_projected, mean_sst)\n\n# And resample to make sure our pixel sizes match \ndepth_resampled &lt;- resample(depth_projected, mean_sst)"
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html#oyster-reclassification",
    "href": "posts/aquaculture_and_eezs/index.html#oyster-reclassification",
    "title": "Aquaculture and EEZ’s",
    "section": "Oyster Reclassification",
    "text": "Oyster Reclassification\nWe need to reclassify for oysters, which enjoy depth between -70 meters and 0 meters and temperatures between 11 and 30 degrees celcius\n\n\nCode\nrcl_depth &lt;- matrix(c(-Inf, -70, 0, # Anything below 70 m becomes a 0\n                    -70, 0, 1, # Between 70 and 0 becomes 1\n                    0, Inf, 0), # And above 0 becomes a 0\n                    nrow = 3, \n                    byrow = TRUE)\n\nrcl_temp &lt;- matrix(c(-Inf, 11, 0, # Below 11 degrees becomes 0\n                     11, 30, 1, # Between 11 and 30 becomes 1\n                     30, Inf, 0), # Above 30 becomes 0\n                   nrow =3,\n                   byrow = TRUE)\n# Apply those matrices\ndepth_rcl &lt;- classify(depth_resampled, rcl_depth) \n\nsst_rcl &lt;- classify(mean_sst, rcl_temp)\n\n\nWe want to keep where both sst and depth equal one, so we can multiply the two rasters.\n\n\nCode\nsuitable_cells &lt;- sst_rcl * depth_rcl\n\n# And make all 0's NA\nsuitable_cells[suitable_cells == 0] &lt;- NA\n\n# Finally, since we only have ones, change that to suitable\nnames(suitable_cells) &lt;- 'Suitable'\n\n\n\n\nCode\n# Now we want to see the area of the suitable cells, which we can get by multiplying suitable_cells and the cellSize of each cell\narea_raster &lt;- suitable_cells * cellSize(suitable_cells, unit = 'km')  \n\n\n\n\nCode\n# Here we extract where that area touches our eez\narea_extracted &lt;- terra::extract(area_raster, \n                                 eez, \n                                 touches = TRUE) %&gt;%  \n  group_by(ID) %&gt;% # Then we group_by and summarise the total suitable area per eez region\n  summarise(suitable_area = sum(Suitable, na.rm = TRUE)) %&gt;% \n  mutate(rgn = eez$rgn)\n\n\n\n\nCode\n# Lastly we want to left join to preserve the area information of each eez region\nregion_suitable_area &lt;- left_join(x = eez,\n                                  y = area_extracted, \n                                  by = \"rgn\") %&gt;% \n  select(-ID) # Get rid of ID column\n\n\n\nMap\nNow we have our final mapping data frame and can build our map\n\n\nCode\ntm_basemap(\"Esri.WorldTopoMap\")+# I found this basemap fit the best\ntm_shape(region_suitable_area)+\n  tm_polygons(fill = 'suitable_area',\n              fill.scale = tm_scale(values = c('#E1DABD', # Add my color palette \n                                              '#ABC798',\n                                              '#FFC4EB',\n                                              '#E6983F',\n                                              '#A0185A'),\n                                    breaks = c(0, \n                                               800, # Specify breaks \n                                               1600,\n                                               2400, \n                                               3200,\n                                               4000)),\n              fill.legend = tm_legend( '        Total \\nSuitable area (km)'))+ # The blank space makes 'Total' centered\n  tm_title(text = paste('Suitable area for farming Oysters in West Coast EEZ'), \n           position = tm_pos_out(\"center\", \"top\", pos.h = \"center\"))+ # Add title and position in center\n  tm_layout(component.autoscale = FALSE)+ # Autoscale makes our title tiny so we turn it off\n  tm_graticules(alpha = .5)+ # Add graticules (lighter)\n  tm_text('rgn', size = .7)+ # This adds the region name on each polygon centroid\ntm_shape(suitable_cells)+ # I want to add the visual representation of where the suitable area is \n  tm_raster(col  =  'Suitable',\n             col.scale =  tm_scale(values = '#90AFDA', # This color is also part of my palette\n            labels = 'Suitable Area'), # In place of a title  we will be specific with our legend text\n            col.legend = tm_legend(title = \"\")) # No need for a legend title with a single raster variable\n\n\n\n\n\n\n\n\n\n\n\nTable\nI also want to be able to see a table of our exact suitable area in each region so we can use kable\n\n\nCode\nregion_suitable_area %&gt;% \n  st_drop_geometry() %&gt;% # The only way to lose geometry\n  select(-rgn_key, -rgn_id, -area_m2) %&gt;% # Drop unnecesary columns\nkbl(col.names = c('Region', 'Total Area (Km2)', 'Suitable Area (Km2)')) %&gt;%  # Rename the columns in our table\n  kable_classic(full_width = F, # This is my favorite type of table\n                html_font = \"Cambria\") %&gt;% \n  footnote(number = paste('EEZ region suitable area for farming Oysters')) # Add a footnote\n\n\n\n\n\nRegion\nTotal Area (Km2)\nSuitable Area (Km2)\n\n\n\n\nOregon\n179994.06\n1147.883\n\n\nNorthern California\n164378.81\n194.126\n\n\nCentral California\n202738.33\n3673.514\n\n\nSouthern California\n206860.78\n3259.485\n\n\nWashington\n66898.31\n2524.804\n\n\n\n1 EEZ region suitable area for farming Oysters"
  },
  {
    "objectID": "posts/aquaculture_and_eezs/index.html#function",
    "href": "posts/aquaculture_and_eezs/index.html#function",
    "title": "Aquaculture and EEZ’s",
    "section": "Function",
    "text": "Function\nNow that I have my workflow solidified I can turn it into a function, so with just the species name it can output a map.\n\n\nCode\n#' Map EEZ\n#' Make a map of a suitable area of a species in west coast EEZ's\n#' @param species \n#' The name of your species, MUST be wrapped AND Uppercase eg: ('Pacific Oyster')\n#' @returnsA list containing:\n#'   - $map   : tmap object\n#'   - $table : kable table\n#' @export\n#' @examples\n#' \nmap_eez &lt;- function(species){\n\n  species_dict &lt;- list(\n  \n  # -----------------------------\n  # SHELLFISH\n  # -----------------------------\n  \n  \"Pacific Oyster\" = list(\n    t_lwr = 11, t_upr = 30,\n    d_lower = 70, d_upr = 0\n  ),\n\n  \"Olympia Oyster\" = list(\n    t_lwr = 8,  t_upr = 20,\n    d_lower = 40, d_upr = 0\n  ),\n\n  \"Geoduck\" = list(\n    t_lwr = 5, t_upr = 18,\n    d_lower = 100, d_upr = 5\n  ),\n\n  \"Razor Clam\" = list(\n    t_lwr = 5, t_upr = 17,\n    d_lower = 20, d_upr = 0\n  ),\n\n  \"Blue Mussel\" = list(\n    t_lwr = 5, t_upr = 20,\n    d_lower = 30, d_upr = 0\n  ),\n\n  \"Mediterranean Mussel\" = list(\n    t_lwr = 8, t_upr = 26,\n    d_lower = 40, d_upr = 0\n  ),\n\n  \"Scallop\" = list(\n    t_lwr = 8, t_upr = 20,\n    d_lower = 50, d_upr = 0\n  ),\n  \n  # -----------------------------\n  # KELP + SEAWEEDS\n  # -----------------------------\n  \n  \"Bull Kelp\" = list(\n    t_lwr = 10, t_upr = 18,\n    d_lower = 40, d_upr = 0\n  ),\n  \n  \"Giant Kelp\" = list(\n    t_lwr = 6,  t_upr = 20,\n    d_lower = 30, d_upr = 0\n  ),\n  \n  \"Sugar Kelp\" = list(\n    t_lwr = -2, t_upr = 15,\n    d_lower = 50, d_upr = 1\n  ),\n  \n  \"Dulse\" = list(\n    t_lwr = 5,  t_upr = 15,\n    d_lower = 10, d_upr = 0\n  ),\n  \n  \"Sea Lettuce\" = list(\n    t_lwr = 5,  t_upr = 25,\n    d_lower = 10, d_upr = 0\n  ),\n  \n  \"Winged Kelp\" = list(\n    t_lwr = 2, t_upr = 15,\n    d_lower = 40, d_upr = 0\n  ),\n\n  \"Pyropia (Nori)\" = list(\n    t_lwr = 5,  t_upr = 15,\n    d_lower = 10, d_upr = 0\n  ),\n  \n  # -----------------------------\n  # ECHINODERMS (URCHINS)\n  # -----------------------------\n  \n  \"Green Sea Urchin\" = list(\n    t_lwr = 0, t_upr = 15,\n    d_lower = 200, d_upr = 0\n  ),\n\n  \"Red Sea Urchin\" = list(\n    t_lwr = 5, t_upr = 20,\n    d_lower = 100, d_upr = 3\n  ),\n  \n  # -----------------------------\n  # FINFISH\n  # -----------------------------\n\n  \"Chinook Salmon\" = list(\n    t_lwr = 8,  t_upr = 14,\n    d_lower = 200, d_upr = 0\n  ),\n\n  \"Coho Salmon\" = list(\n    t_lwr = 7, t_upr = 14,\n    d_lower = 150, d_upr = 0\n  ),\n\n  \"Steelhead Trout\" = list(\n    t_lwr = 7, t_upr = 17,\n    d_lower = 100, d_upr = 0\n  ),\n\n  \"Pacific Halibut\" = list(\n    t_lwr = 3,  t_upr = 12,\n    d_lower = 450, d_upr = 20\n  ),\n\n  \"Sablefish\" = list(\n    t_lwr = 4,  t_upr = 12,\n    d_lower = 1500, d_upr = 50\n  ),\n\n  \"Pacific Sardine\" = list(\n    t_lwr = 12, t_upr = 20,\n    d_lower = 0, d_upr = 50\n  ),\n\n  \"Northern Anchovy\" = list(\n    t_lwr = 12, t_upr = 20,\n    d_lower = 0, d_upr = 50\n  ),\n  \n  # -----------------------------\n  # CRUSTACEANS\n  # -----------------------------\n\n  \"Dungeness Crab\" = list(\n    t_lwr = 7, t_upr = 18,\n    d_lower = 100, d_upr = 0\n  )\n)\n\n# Extract parameters from the dictionary\nparams &lt;- species_dict[[species]]\nif (species == \"list\") {\n  return(names(species_dict))\n}\n\nif (is.null(params)) stop(\"Species not found in dictionary. Check spelling.\")\n\n# Access individual values\nt_lwr &lt;- params$t_lwr\nt_upr &lt;- params$t_upr\nd_lower &lt;- params$d_lower\nd_upr   &lt;- params$d_upr\n\n# Reclassification matrices\nrcl_depth &lt;- matrix(c(-Inf, -d_lower, 0, # Use variables like values\n                      -d_lower, -d_upr, 1,\n                      -d_upr, Inf, 0), \n                    nrow = 3, \n                    byrow = TRUE)\n\nrcl_temp &lt;- matrix(c(-Inf, t_lwr, 0,\n                     t_lwr, t_upr, 1,\n                     t_upr, Inf, 0), \n                   nrow =3,\n                   byrow = TRUE)\n\n# Reclassify \ndepth_rcl &lt;- classify(depth_resampled, rcl_depth)\n\nsst_rcl &lt;- classify(mean_sst, rcl_temp)\n\n# Calculate suitable cells\nsuitable_cells &lt;- sst_rcl * depth_rcl\n\nsuitable_cells[suitable_cells == 0] &lt;- NA\n\nnames(suitable_cells) &lt;- 'Suitable'\n\n# Calculate area of suitable cells\narea_raster &lt;- suitable_cells * cellSize(suitable_cells, unit = 'km')\n\n# Extract suitable areas \narea_extracted &lt;- terra::extract(area_raster, \n                                 eez, \n                                 touches = TRUE) %&gt;%  \n  group_by(ID) %&gt;% \n  summarise(suitable_area = sum(Suitable, na.rm = TRUE)) %&gt;% \n  mutate(rgn = eez$rgn)\n\n# Create geodf with suitable area and eez area\nregion_suitable_area &lt;- left_join(x = eez,\n                                  y = area_extracted, \n                                  by = \"rgn\") %&gt;% \n  select(-ID)\n\n\n# Create map\nmap &lt;- tm_basemap(\"Esri.WorldTopoMap\")+\n  tm_shape(region_suitable_area)+\n  tm_polygons(fill = 'suitable_area',\n              fill.scale = tm_scale(values = c('#E1DABD',\n                                               '#ABC798',\n                                               '#FFC4EB',\n                                               '#E6983F',\n                                               '#A0185A'),\n                                    n = 5), # Set 5 breaks\n              fill.legend = tm_legend( '        Total \\nSuitable area (km)'))+\n  tm_title(text = paste('Suitable area for farming', species, 'in West Coast EEZ'), position = tm_pos_out(\"center\", \"top\", pos.h = \"center\"))+ # Paste allows us to manipulate the title of the plot\n  tm_layout(component.autoscale = FALSE)+\n  tm_graticules(alpha = .5)+\n  tm_text('rgn', size = .7)+\ntm_shape(suitable_cells)+\n  tm_raster(col  =  'Suitable',\n             col.scale =  tm_scale(values = '#90AFDA', \n            labels = 'Suitable Area'),\n            col.legend = tm_legend(title = \"\"))\n\n# Create table\ntable &lt;- region_suitable_area %&gt;% \n  st_drop_geometry() %&gt;% \n  select(-rgn_key, -rgn_id, -area_m2) %&gt;% \nkbl(col.names = c('Region', \n                  'Total Area (Km2)', \n                  'Suitable Area (Km2)')) %&gt;% \n  kable_classic(full_width = F, \n                html_font = \"Cambria\") %&gt;% \n  footnote(number = paste('EEZ region suitable area for farming', species)) # Paste again\n\nreturn(list( # Make a list of our map and table so they can be called with a buck\n    map = map, \n    table = table\n  ))\n}\n\n\nNow we can call the function for any species in our species list\nTo know species options you can run map_eez(‘list’)\n\nmap_eez('list')\n\n [1] \"Pacific Oyster\"       \"Olympia Oyster\"       \"Geoduck\"             \n [4] \"Razor Clam\"           \"Blue Mussel\"          \"Mediterranean Mussel\"\n [7] \"Scallop\"              \"Bull Kelp\"            \"Giant Kelp\"          \n[10] \"Sugar Kelp\"           \"Dulse\"                \"Sea Lettuce\"         \n[13] \"Winged Kelp\"          \"Pyropia (Nori)\"       \"Green Sea Urchin\"    \n[16] \"Red Sea Urchin\"       \"Chinook Salmon\"       \"Coho Salmon\"         \n[19] \"Steelhead Trout\"      \"Pacific Halibut\"      \"Sablefish\"           \n[22] \"Pacific Sardine\"      \"Northern Anchovy\"     \"Dungeness Crab\"      \n\n\nNow we can call the function with any species from the list we find interesting, in this case Bull Kelp AND WHY\n\nbull_kelp &lt;- map_eez('Bull Kelp')\n\nCall the map\n\nbull_kelp$map\n\n\n\n\n\n\n\n\nCall the table\n\nbull_kelp$table\n\n\n\n\nRegion\nTotal Area (Km2)\nSuitable Area (Km2)\n\n\n\n\nOregon\n179994.06\n1065.055\n\n\nNorthern California\n164378.81\n1023.031\n\n\nCentral California\n202738.33\n1674.401\n\n\nSouthern California\n206860.78\n1622.344\n\n\nWashington\n66898.31\n3246.458\n\n\n\n1 EEZ region suitable area for farming Bull Kelp"
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html",
    "href": "posts/palisades_eaton_ejscreen/index.html",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "In this project we will be using true and false color imagery to examine the impacts of two fires which struck the Los Angeles area in early 2025.\n\n\n\nExtracting color bands from xarray\nMapping using true and false color imagery\nOverlaying fire perimiters to see effect of fires\n\n\n\n\n\n\nThese contain dissolved fire perimeters/boundaries for Eaton and Palisades fires, with boundary polygons dissolved for each fire to create a single fire burn perimeter. Access given by the County of Los Angeles.\n\n\n\nLandsat C2 L2 from Microsoft’s Planetary Computer is a globally available, multi-decadal archive of atmospherically corrected, analysis-ready Landsat imagery. Surface reflectance for multispectral bands and derived land surface temperature from thermal bands are provided in cloud-optimized GeoTIFFs, accessible via a STAC API. Accordingly, it is primarily used for long-term environmental monitoring, spectral studies, and thermal remote sensing, and is designed for scalable, cloud-native remote sensing workflows.\n\n\n\n\n\nLos Angeles GeoHub / NIFC FIRIS. (2025). Palisades-Eaton dissolved fire perimeters [data file]. Available: https://geohub.lacity.org/datasets/lacounty::palisades-and-eaton-dissolved-fire-perimeters-2025. [Accessed: Nov. 15, 2025]\nU.S. Geological Survey. Landsat Collection 2 Level-2 Surface Reflectance (Microsoft Planetary Computer version) Idata file Available: https://planetarycomputer.microsoft.com/dataset/landsat-c2-12. [Accessed: Nov. 15, 2025]\n\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd \nimport matplotlib.pyplot as plt\nimport os \nimport xarray as xr\nimport rioxarray as rio\nimport numpy as np \nfrom matplotlib_scalebar.scalebar import ScaleBar\n\n\n\n\n\n\nExplore the fire perimeter data and write a brief summary of the information you obtained from the preliminary exploration. Your summary should include, at least, the CRS of the data and whether this is projected or geographic.\nI am going to import both perimeters and then look at the CRS.\n\n\nCode\nfp = os.path.join('data','Eaton_Perimeter_20250121','Eaton_Perimeter_20250121.shp')\neaton_perimeter = gpd.read_file(fp)\n\n\n\n\nCode\nfp = os.path.join('data','Palisades_Perimeter_20250121','Palisades_Perimeter_20250121.shp')\npalisades_perimeter = gpd.read_file(fp)\n\n\n\n\nCode\n# Now we can look at the crs's and do some exploration \npalisades_perimeter.crs\n\n\n&lt;Projected CRS: EPSG:3857&gt;\nName: WGS 84 / Pseudo-Mercator\nAxis Info [cartesian]:\n- X[east]: Easting (metre)\n- Y[north]: Northing (metre)\nArea of Use:\n- name: World between 85.06°S and 85.06°N.\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\n\nCode\neaton_perimeter.crs\n\n\n&lt;Projected CRS: EPSG:3857&gt;\nName: WGS 84 / Pseudo-Mercator\nAxis Info [cartesian]:\n- X[east]: Easting (metre)\n- Y[north]: Northing (metre)\nArea of Use:\n- name: World between 85.06°S and 85.06°N.\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\n\nCode\n# Lets compare the column names to make sure they match \n\nprint(f' It is {eaton_perimeter.columns == palisades_perimeter.columns} that he column names match')\n\n\n It is [ True  True  True  True  True] that he column names match\n\n\n\n\nCode\n# Thats great we only need to look at one of the dataframes columns \n\neaton_perimeter.columns\n\n\nIndex(['OBJECTID', 'type', 'Shape__Are', 'Shape__Len', 'geometry'], dtype='object')\n\n\n\n\nCode\n# Might need some work \n\n\nSummary: From the preliminary exploration both the Palisades and Eaton datasets are in ESPG:3857, which is a projected coordinate system. Both have the same column names which will make analysis easier, however we may need to edit the column names, though none are incredibly bad (e.g having a space in the name).\n\n\n\nImport the Landsat data using xr.open_dataset().\nExplore the data and write a brief summary of the information you obtained from the preliminary information. Your summary should include the a description of the data’s variables, dimensions, and coordinates.\n\n\nCode\nnetcdf = xr.open_dataset('data/landsat8-2025-02-23-palisades-eaton.nc')\n\n\n\n\nCode\nnetcdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 78MB\nDimensions:      (y: 1418, x: 2742)\nCoordinates:\n  * y            (y) float64 11kB 3.799e+06 3.799e+06 ... 3.757e+06 3.757e+06\n  * x            (x) float64 22kB 3.344e+05 3.344e+05 ... 4.166e+05 4.166e+05\n    time         datetime64[ns] 8B ...\nData variables:\n    red          (y, x) float32 16MB ...\n    green        (y, x) float32 16MB ...\n    blue         (y, x) float32 16MB ...\n    nir08        (y, x) float32 16MB ...\n    swir22       (y, x) float32 16MB ...\n    spatial_ref  int64 8B ...xarray.DatasetDimensions:y: 1418x: 2742Coordinates: (3)y(y)float643.799e+06 3.799e+06 ... 3.757e+06units :metreresolution :-30.0crs :EPSG:32611axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinatearray([3799050., 3799020., 3798990., ..., 3756600., 3756570., 3756540.])x(x)float643.344e+05 3.344e+05 ... 4.166e+05units :metreresolution :30.0crs :EPSG:32611axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinatearray([334410., 334440., 334470., ..., 416580., 416610., 416640.])time()datetime64[ns]...[1 values with dtype=datetime64[ns]]Data variables: (6)red(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]green(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]blue(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]nir08(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]swir22(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]spatial_ref()int64...crs_wkt :PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :WGS 84 / UTM zone 11Ngrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-117.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]GeoTransform :334395.0 30.0 0.0 3799065.0 0.0 -30.0[1 values with dtype=int64]Indexes: (2)yPandasIndexPandasIndex(Index([3799050.0, 3799020.0, 3798990.0, 3798960.0, 3798930.0, 3798900.0,\n       3798870.0, 3798840.0, 3798810.0, 3798780.0,\n       ...\n       3756810.0, 3756780.0, 3756750.0, 3756720.0, 3756690.0, 3756660.0,\n       3756630.0, 3756600.0, 3756570.0, 3756540.0],\n      dtype='float64', name='y', length=1418))xPandasIndexPandasIndex(Index([334410.0, 334440.0, 334470.0, 334500.0, 334530.0, 334560.0, 334590.0,\n       334620.0, 334650.0, 334680.0,\n       ...\n       416370.0, 416400.0, 416430.0, 416460.0, 416490.0, 416520.0, 416550.0,\n       416580.0, 416610.0, 416640.0],\n      dtype='float64', name='x', length=2742))Attributes: (0)\n\n\nThis xarray has 1418 y dimensions and 2742 x dimensions. The coordinates are x, y, and time which are are float64, float64, and datetime64 types (respectively). The variables are red, green, blue, near infared and short wave infared light bands as well as a spatial reference. The bands are in float32 while the spatial_ref is an int64, this shouldn’t be an issue going further - however as the analysis continues it may become an issue.\n\n\n\nUse rio.crs to print what is the CRS of this dataset. Is this a geospatial object?\nYou may have noticed on section 3 that the geospatial information for this dataset is stored in the variable spatial_ref. Print the CRS by using accesing the spatial_ref.crs_wkt attribute of the dataset.\nRecover the geospatial information by using rio.write_crs() and the spatial reference information form part b.\nPrint the CRS of the updated dataset.\n\n\nCode\nprint(f'The xarray has the crs: {netcdf.rio.crs}')\n\n\nThe xarray has the crs: None\n\n\nOh no! Theres no crs meaning that it will be harder to plot, however there actually is! It’s just encoded in the spatial_ref variable.\n\n\nCode\nprint(f' The actual crs of the xarray is: {netcdf.spatial_ref.crs_wkt}')\n\n\n The actual crs of the xarray is: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\n\n\nOh wow thats big! Lets make it so that crs is the crs for the dataset\n\n\nCode\nnetcdf = netcdf.rio.write_crs(netcdf.spatial_ref.crs_wkt) # Need to write_crs due to being an xarrray\n\n\n\n\nCode\nprint(f'The xarray now has the crs: {netcdf.rio.crs}')\n\n\nThe xarray now has the crs: EPSG:32611\n\n\n\n\n\nWithout creating any new variables: - select the red, green, and blue variables (in that order) of the xarray.Dataset holding the Landsat data, - convert it to a numpy.array using the to_array() method, and then - use .plot.imshow() to create an RGB image with the data. There will be two warnings, that’s ok. - Adjust the scale used for plotting the bands to get a true color image.\n\nTo resolve the other warning, identify which bands have nan values.\nUse the .fillna() mehtod for xarray.Datasets to substitute the any nan values in the Landsat data for zero.\nCreate a new true color image that gets plotted without warnings.\nIn a markdown cell write a brief explanation comparing the ouputs for parts (a) and (e).\n\n\n\nCode\nnetcdf[['red', 'green', 'blue']].to_array().plot.imshow() # Plot red, green and blue bands\n\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n/opt/anaconda3/envs/eds220-env/lib/python3.11/site-packages/matplotlib/cm.py:478: RuntimeWarning: invalid value encountered in cast\n  xx = (xx * 255).astype(np.uint8)\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(f'The red band has {np.isnan(netcdf.red).sum().item()} na values')\nprint(f'The green band has {np.isnan(netcdf.green).sum().item()} na values')\nprint(f'The blue band has {np.isnan(netcdf.blue).sum().item()} na values')\n\n\nThe red band has 0 na values\nThe green band has 1 na values\nThe blue band has 109 na values\n\n\n\n\nCode\nnetcdf[['red', 'green', 'blue']].fillna(0).to_array().plot.imshow(robust = True) # Fillna and robust = true are the fix for the two problems\n\n\n\n\n\n\n\n\n\nExplanation: The code for the two plots is relatively similar, however the first runs an error. This is because of two reasons: NA’s and how the data is stored. As we saw in my f-prints there are a total of 110 NA Values. The data also contains some extreme outliers, which run into an error when plotting. By selecting robust = TRUE, the outlier values are minimized by using the second and 98th percentile of values to minimize outliers. Furthermore fillna(0) makes it so all our NA values become 0.\n\n\n\nWithout creating any new variables, create a false color image by plotting the short-wave infrared (swir22), near-infrared, and red variables (in that order).\n\n\nCode\n# This plotting code is very similar to the other, but we are selecting bands\nnetcdf[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True) # Note! No Na's are present\n\n\n\n\n\n\n\n\n\n\n\n\nCreate a map showing the shortwave infrared/near-infrared/red false color image together with both fire perimeters. Customize it appropriately including, at least, an informative title and legend. You may also want to include text on the map to identify which fire is which.\nWrite a figure description for the map including a brief explanation of how false color imagery is being used.\n\n\nCode\n# Before we plot we need to ensure we are in the same crs\npalisades_perimeter = palisades_perimeter.to_crs(netcdf.rio.crs)\n\n\neaton_perimeter = eaton_perimeter.to_crs(netcdf.rio.crs)\n\n\n\n\nCode\n \n\nfig, ax = plt.subplots(1, 1, figsize = (14,12)) # Set a size for our figure\n\nnetcdf[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True, ax = ax) # Choose false color bands\n\neaton_perimeter.plot(ax = ax, color = 'none', edgecolor = 'red') # Plot Eaton fire perimeter in red\n\npalisades_perimeter.plot(ax = ax, color = 'none', edgecolor = 'red') # And the Palisade perimeter\n\n\nplt.suptitle('False Color image of Palisades and Eaton fires in Santa Barbara', \n             fontsize=16, \n             y = .77) # This y was a lot of guess and checking \nplt.title(\"Plot of SWIR, NIR, and RED light bands\", \n          fontsize=12, \n          y=1.01) # Title defaults inside the plot and I want it just above, hence 1.01\n\n\n\nplt.figtext(x = .2, # The position of the figtext, In units of 0-1 for x and y \n            y = .46,\n            s = 'Palisades Fire Perimeter',\n            color = 'black',\n            bbox ={'facecolor':'grey',  # Add a box around text for legibility \n                   'alpha':1, 'pad':5}) \nplt.figtext(x = .67, \n            y = .63, \n            s= 'Eaton Fire Perimeter',\n            color = 'black',\n           bbox ={'facecolor':'grey', \n                   'alpha':1, 'pad':5})\n\nax.add_artist(ScaleBar(1, dimension=\"si-length\", units=\"m\", location=\"lower left\")) # Add a scale bar on the lower left\n\nax.axis('off') # Turn Axes off\n\nplt.show() # Show plot only \n\n\n\n\n\n\n\n\n\nMap description: Short-wave infrared (SWIR) was mapped to the red channel, near-infrared (NIR) to green, and the red band to blue. This false-color composite highlights post-fire effects from the January 2025 Palisades–Eaton fires. Burned areas appear as bright orange to deep red, while the fire perimeter is outlined in red for clarity, with the fire name next to the perimeter."
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#about-this-notebook",
    "href": "posts/palisades_eaton_ejscreen/index.html#about-this-notebook",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "In this project we will be using true and false color imagery to examine the impacts of two fires which struck the Los Angeles area in early 2025.\n\n\n\nExtracting color bands from xarray\nMapping using true and false color imagery\nOverlaying fire perimiters to see effect of fires\n\n\n\n\n\n\nThese contain dissolved fire perimeters/boundaries for Eaton and Palisades fires, with boundary polygons dissolved for each fire to create a single fire burn perimeter. Access given by the County of Los Angeles.\n\n\n\nLandsat C2 L2 from Microsoft’s Planetary Computer is a globally available, multi-decadal archive of atmospherically corrected, analysis-ready Landsat imagery. Surface reflectance for multispectral bands and derived land surface temperature from thermal bands are provided in cloud-optimized GeoTIFFs, accessible via a STAC API. Accordingly, it is primarily used for long-term environmental monitoring, spectral studies, and thermal remote sensing, and is designed for scalable, cloud-native remote sensing workflows.\n\n\n\n\n\nLos Angeles GeoHub / NIFC FIRIS. (2025). Palisades-Eaton dissolved fire perimeters [data file]. Available: https://geohub.lacity.org/datasets/lacounty::palisades-and-eaton-dissolved-fire-perimeters-2025. [Accessed: Nov. 15, 2025]\nU.S. Geological Survey. Landsat Collection 2 Level-2 Surface Reflectance (Microsoft Planetary Computer version) Idata file Available: https://planetarycomputer.microsoft.com/dataset/landsat-c2-12. [Accessed: Nov. 15, 2025]\n\n\n\nCode\nimport pandas as pd\nimport geopandas as gpd \nimport matplotlib.pyplot as plt\nimport os \nimport xarray as xr\nimport rioxarray as rio\nimport numpy as np \nfrom matplotlib_scalebar.scalebar import ScaleBar"
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#fire-perimeter-data-exploration",
    "href": "posts/palisades_eaton_ejscreen/index.html#fire-perimeter-data-exploration",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Explore the fire perimeter data and write a brief summary of the information you obtained from the preliminary exploration. Your summary should include, at least, the CRS of the data and whether this is projected or geographic.\nI am going to import both perimeters and then look at the CRS.\n\n\nCode\nfp = os.path.join('data','Eaton_Perimeter_20250121','Eaton_Perimeter_20250121.shp')\neaton_perimeter = gpd.read_file(fp)\n\n\n\n\nCode\nfp = os.path.join('data','Palisades_Perimeter_20250121','Palisades_Perimeter_20250121.shp')\npalisades_perimeter = gpd.read_file(fp)\n\n\n\n\nCode\n# Now we can look at the crs's and do some exploration \npalisades_perimeter.crs\n\n\n&lt;Projected CRS: EPSG:3857&gt;\nName: WGS 84 / Pseudo-Mercator\nAxis Info [cartesian]:\n- X[east]: Easting (metre)\n- Y[north]: Northing (metre)\nArea of Use:\n- name: World between 85.06°S and 85.06°N.\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\n\nCode\neaton_perimeter.crs\n\n\n&lt;Projected CRS: EPSG:3857&gt;\nName: WGS 84 / Pseudo-Mercator\nAxis Info [cartesian]:\n- X[east]: Easting (metre)\n- Y[north]: Northing (metre)\nArea of Use:\n- name: World between 85.06°S and 85.06°N.\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n\n\n\nCode\n# Lets compare the column names to make sure they match \n\nprint(f' It is {eaton_perimeter.columns == palisades_perimeter.columns} that he column names match')\n\n\n It is [ True  True  True  True  True] that he column names match\n\n\n\n\nCode\n# Thats great we only need to look at one of the dataframes columns \n\neaton_perimeter.columns\n\n\nIndex(['OBJECTID', 'type', 'Shape__Are', 'Shape__Len', 'geometry'], dtype='object')\n\n\n\n\nCode\n# Might need some work \n\n\nSummary: From the preliminary exploration both the Palisades and Eaton datasets are in ESPG:3857, which is a projected coordinate system. Both have the same column names which will make analysis easier, however we may need to edit the column names, though none are incredibly bad (e.g having a space in the name)."
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#netcdf-data-import-and-exploration",
    "href": "posts/palisades_eaton_ejscreen/index.html#netcdf-data-import-and-exploration",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Import the Landsat data using xr.open_dataset().\nExplore the data and write a brief summary of the information you obtained from the preliminary information. Your summary should include the a description of the data’s variables, dimensions, and coordinates.\n\n\nCode\nnetcdf = xr.open_dataset('data/landsat8-2025-02-23-palisades-eaton.nc')\n\n\n\n\nCode\nnetcdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 78MB\nDimensions:      (y: 1418, x: 2742)\nCoordinates:\n  * y            (y) float64 11kB 3.799e+06 3.799e+06 ... 3.757e+06 3.757e+06\n  * x            (x) float64 22kB 3.344e+05 3.344e+05 ... 4.166e+05 4.166e+05\n    time         datetime64[ns] 8B ...\nData variables:\n    red          (y, x) float32 16MB ...\n    green        (y, x) float32 16MB ...\n    blue         (y, x) float32 16MB ...\n    nir08        (y, x) float32 16MB ...\n    swir22       (y, x) float32 16MB ...\n    spatial_ref  int64 8B ...xarray.DatasetDimensions:y: 1418x: 2742Coordinates: (3)y(y)float643.799e+06 3.799e+06 ... 3.757e+06units :metreresolution :-30.0crs :EPSG:32611axis :Ylong_name :y coordinate of projectionstandard_name :projection_y_coordinatearray([3799050., 3799020., 3798990., ..., 3756600., 3756570., 3756540.])x(x)float643.344e+05 3.344e+05 ... 4.166e+05units :metreresolution :30.0crs :EPSG:32611axis :Xlong_name :x coordinate of projectionstandard_name :projection_x_coordinatearray([334410., 334440., 334470., ..., 416580., 416610., 416640.])time()datetime64[ns]...[1 values with dtype=datetime64[ns]]Data variables: (6)red(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]green(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]blue(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]nir08(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]swir22(y, x)float32...grid_mapping :spatial_ref[3888156 values with dtype=float32]spatial_ref()int64...crs_wkt :PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :WGS 84 / UTM zone 11Ngrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :-117.0false_easting :500000.0false_northing :0.0scale_factor_at_central_meridian :0.9996spatial_ref :PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]GeoTransform :334395.0 30.0 0.0 3799065.0 0.0 -30.0[1 values with dtype=int64]Indexes: (2)yPandasIndexPandasIndex(Index([3799050.0, 3799020.0, 3798990.0, 3798960.0, 3798930.0, 3798900.0,\n       3798870.0, 3798840.0, 3798810.0, 3798780.0,\n       ...\n       3756810.0, 3756780.0, 3756750.0, 3756720.0, 3756690.0, 3756660.0,\n       3756630.0, 3756600.0, 3756570.0, 3756540.0],\n      dtype='float64', name='y', length=1418))xPandasIndexPandasIndex(Index([334410.0, 334440.0, 334470.0, 334500.0, 334530.0, 334560.0, 334590.0,\n       334620.0, 334650.0, 334680.0,\n       ...\n       416370.0, 416400.0, 416430.0, 416460.0, 416490.0, 416520.0, 416550.0,\n       416580.0, 416610.0, 416640.0],\n      dtype='float64', name='x', length=2742))Attributes: (0)\n\n\nThis xarray has 1418 y dimensions and 2742 x dimensions. The coordinates are x, y, and time which are are float64, float64, and datetime64 types (respectively). The variables are red, green, blue, near infared and short wave infared light bands as well as a spatial reference. The bands are in float32 while the spatial_ref is an int64, this shouldn’t be an issue going further - however as the analysis continues it may become an issue."
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#restoring-geospatial-information",
    "href": "posts/palisades_eaton_ejscreen/index.html#restoring-geospatial-information",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Use rio.crs to print what is the CRS of this dataset. Is this a geospatial object?\nYou may have noticed on section 3 that the geospatial information for this dataset is stored in the variable spatial_ref. Print the CRS by using accesing the spatial_ref.crs_wkt attribute of the dataset.\nRecover the geospatial information by using rio.write_crs() and the spatial reference information form part b.\nPrint the CRS of the updated dataset.\n\n\nCode\nprint(f'The xarray has the crs: {netcdf.rio.crs}')\n\n\nThe xarray has the crs: None\n\n\nOh no! Theres no crs meaning that it will be harder to plot, however there actually is! It’s just encoded in the spatial_ref variable.\n\n\nCode\nprint(f' The actual crs of the xarray is: {netcdf.spatial_ref.crs_wkt}')\n\n\n The actual crs of the xarray is: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\n\n\nOh wow thats big! Lets make it so that crs is the crs for the dataset\n\n\nCode\nnetcdf = netcdf.rio.write_crs(netcdf.spatial_ref.crs_wkt) # Need to write_crs due to being an xarrray\n\n\n\n\nCode\nprint(f'The xarray now has the crs: {netcdf.rio.crs}')\n\n\nThe xarray now has the crs: EPSG:32611"
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#true-color-image",
    "href": "posts/palisades_eaton_ejscreen/index.html#true-color-image",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Without creating any new variables: - select the red, green, and blue variables (in that order) of the xarray.Dataset holding the Landsat data, - convert it to a numpy.array using the to_array() method, and then - use .plot.imshow() to create an RGB image with the data. There will be two warnings, that’s ok. - Adjust the scale used for plotting the bands to get a true color image.\n\nTo resolve the other warning, identify which bands have nan values.\nUse the .fillna() mehtod for xarray.Datasets to substitute the any nan values in the Landsat data for zero.\nCreate a new true color image that gets plotted without warnings.\nIn a markdown cell write a brief explanation comparing the ouputs for parts (a) and (e).\n\n\n\nCode\nnetcdf[['red', 'green', 'blue']].to_array().plot.imshow() # Plot red, green and blue bands\n\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n/opt/anaconda3/envs/eds220-env/lib/python3.11/site-packages/matplotlib/cm.py:478: RuntimeWarning: invalid value encountered in cast\n  xx = (xx * 255).astype(np.uint8)\n\n\n\n\n\n\n\n\n\n\n\nCode\nprint(f'The red band has {np.isnan(netcdf.red).sum().item()} na values')\nprint(f'The green band has {np.isnan(netcdf.green).sum().item()} na values')\nprint(f'The blue band has {np.isnan(netcdf.blue).sum().item()} na values')\n\n\nThe red band has 0 na values\nThe green band has 1 na values\nThe blue band has 109 na values\n\n\n\n\nCode\nnetcdf[['red', 'green', 'blue']].fillna(0).to_array().plot.imshow(robust = True) # Fillna and robust = true are the fix for the two problems\n\n\n\n\n\n\n\n\n\nExplanation: The code for the two plots is relatively similar, however the first runs an error. This is because of two reasons: NA’s and how the data is stored. As we saw in my f-prints there are a total of 110 NA Values. The data also contains some extreme outliers, which run into an error when plotting. By selecting robust = TRUE, the outlier values are minimized by using the second and 98th percentile of values to minimize outliers. Furthermore fillna(0) makes it so all our NA values become 0."
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#false-color-image",
    "href": "posts/palisades_eaton_ejscreen/index.html#false-color-image",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Without creating any new variables, create a false color image by plotting the short-wave infrared (swir22), near-infrared, and red variables (in that order).\n\n\nCode\n# This plotting code is very similar to the other, but we are selecting bands\nnetcdf[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True) # Note! No Na's are present"
  },
  {
    "objectID": "posts/palisades_eaton_ejscreen/index.html#map",
    "href": "posts/palisades_eaton_ejscreen/index.html#map",
    "title": "Visualizing the 2025 California Wildfires",
    "section": "",
    "text": "Create a map showing the shortwave infrared/near-infrared/red false color image together with both fire perimeters. Customize it appropriately including, at least, an informative title and legend. You may also want to include text on the map to identify which fire is which.\nWrite a figure description for the map including a brief explanation of how false color imagery is being used.\n\n\nCode\n# Before we plot we need to ensure we are in the same crs\npalisades_perimeter = palisades_perimeter.to_crs(netcdf.rio.crs)\n\n\neaton_perimeter = eaton_perimeter.to_crs(netcdf.rio.crs)\n\n\n\n\nCode\n \n\nfig, ax = plt.subplots(1, 1, figsize = (14,12)) # Set a size for our figure\n\nnetcdf[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True, ax = ax) # Choose false color bands\n\neaton_perimeter.plot(ax = ax, color = 'none', edgecolor = 'red') # Plot Eaton fire perimeter in red\n\npalisades_perimeter.plot(ax = ax, color = 'none', edgecolor = 'red') # And the Palisade perimeter\n\n\nplt.suptitle('False Color image of Palisades and Eaton fires in Santa Barbara', \n             fontsize=16, \n             y = .77) # This y was a lot of guess and checking \nplt.title(\"Plot of SWIR, NIR, and RED light bands\", \n          fontsize=12, \n          y=1.01) # Title defaults inside the plot and I want it just above, hence 1.01\n\n\n\nplt.figtext(x = .2, # The position of the figtext, In units of 0-1 for x and y \n            y = .46,\n            s = 'Palisades Fire Perimeter',\n            color = 'black',\n            bbox ={'facecolor':'grey',  # Add a box around text for legibility \n                   'alpha':1, 'pad':5}) \nplt.figtext(x = .67, \n            y = .63, \n            s= 'Eaton Fire Perimeter',\n            color = 'black',\n           bbox ={'facecolor':'grey', \n                   'alpha':1, 'pad':5})\n\nax.add_artist(ScaleBar(1, dimension=\"si-length\", units=\"m\", location=\"lower left\")) # Add a scale bar on the lower left\n\nax.axis('off') # Turn Axes off\n\nplt.show() # Show plot only \n\n\n\n\n\n\n\n\n\nMap description: Short-wave infrared (SWIR) was mapped to the red channel, near-infrared (NIR) to green, and the red band to blue. This false-color composite highlights post-fire effects from the January 2025 Palisades–Eaton fires. Burned areas appear as bright orange to deep red, while the fire perimeter is outlined in red for clarity, with the fire name next to the perimeter."
  },
  {
    "objectID": "posts/extreme_weather_events/index.html",
    "href": "posts/extreme_weather_events/index.html",
    "title": "Extreme Weather Events",
    "section": "",
    "text": "This is where the body of my blog post begins! I’m going to add a footnote here 1 Here’s and inline footnote2\nCiting reference (Shanny-Csik 2022)\nlets cite a paper using the DOI (Gaynor et al. 2022)"
  },
  {
    "objectID": "posts/extreme_weather_events/index.html#footnotes",
    "href": "posts/extreme_weather_events/index.html#footnotes",
    "title": "Extreme Weather Events",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere is some additional context that might be helpful↩︎\nhere’s my inline note↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Peter Vitale",
    "section": "",
    "text": "I’m a marine biologist with a passion for ocean life, data visualization, and science communication. I studied Marine Biology at UC Santa Cruz and have worked in environmental education, field research, and data analysis. I enjoy finding creative ways to connect people with the natural world and make environmental data more engaging and accessible."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog Posts",
    "section": "",
    "text": "Visualizing the 2025 California Wildfires\n\n\n\nMEDS\n\nGeospatial\n\nPython\n\n\n\nPlotting true and false color images with landsat data.\n\n\n\nPeter Vitale\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\nAquaculture and EEZ’s\n\n\n\nMEDS\n\nR\n\nGeospatial\n\n\n\nExamining where in the North Pacific Economic Exclusive Zone is best for aquaculture of different species\n\n\n\nPeter Vitale\n\n\nNov 28, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtreme Weather Events\n\n\n\nMEDS\n\nR\n\nGeospatial\n\n\n\nExamining blackouts in Houston,TX following a 2021 storm\n\n\n\nPeter Vitale\n\n\nNov 12, 2025\n\n\n\n\n\n\nNo matching items"
  }
]